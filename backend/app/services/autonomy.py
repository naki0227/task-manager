import logging
import json
from sqlalchemy.orm import Session
from datetime import datetime

from app.services.rag_service import get_rag_service
from app.services.gemini_service import get_gemini_service
from app.models import Task, Proposal
# from app.routers.tasks import get_tasks_crud

logger = logging.getLogger(__name__)

class AutonomyService:
    def __init__(self, db: Session):
        self.db = db
        self.rag = get_rag_service()
        self.gemini = get_gemini_service()

    async def run_loop(self, user_id: int):
        """
        The Core Autonomous Loop.
        1. Gather Context (RAG + SQL)
        2. Think (Gemini)
        3. Propose Actions
        """
        logger.info(f"Running autonomous loop for user {user_id}")
        
        # 1. Gather Context
        # A. RAG Context (Calendar, Emails, etc.)
        # A. RAG Context (Calendar, Emails, etc.)
        rag_results = await self.rag.query_codebase("What are my upcoming events, recent emails, and slack conversations?", n_results=10)
        # rag_context = "\n".join([f"- {r['content']} (Source: {r['source']})" for r in rag_results])
        rag_context = rag_results # Pass list of dicts directly
        
        # B. DB Context (Tasks)
        # Use existing CRUD or query directly
        tasks = self.db.query(Task).filter(
            Task.user_id == user_id, 
            Task.status.in_(["pending", "ready", "in_progress"])
        ).limit(10).all()
        task_context = "\n".join([f"- [{t.status}] {t.title} (Due: {t.estimated_time})" for t in tasks])
        
        
        # 3. Safety Check
        from app.services.safety import SafetyService
        safety = SafetyService(self.db)
        if not safety.check_rate_limit(user_id):
            logger.warning(f"Rate limit exceeded for user {user_id}")
            return 0
            
        # 4. Think
        # 4. Think
        from app.services.reasoning import ReasoningService
        reasoning = ReasoningService()
        proposals_data = await reasoning.analyze_context_and_propose(rag_context, task_context)
        
        try:
            # result = await self.gemini._generate_json(prompt) # Removed
            # proposals_data = result.get("proposals", []) # Removed
            
            created_proposals = []
            if not proposals_data:
                 logger.warning("No proposals generated by ReasoningService")
            
            for p in proposals_data:
                # Deduplication skipped for brevity
                
                proposal = Proposal(
                    user_id=user_id,
                    title=p.get("title", "No Title"),
                    description=p.get("description", ""),
                    type=p.get("type", "advice"),
                    payload=json.dumps(p.get("payload", {})),
                    status="pending"
                )
                self.db.add(proposal)
                self.db.commit() # Commit specifically to get ID if needed, but here just commit per item
                
                # Log Safety
                safety.log_action(
                    user_id=user_id,
                    action_type="proposal_generated",
                    resource_type=p.get("type", "unknown"),
                    details={"title": p.get("title")},
                    risk_level=p.get("risk_level", "low")
                )
                created_proposals.append(proposal)
            
            logger.info(f"Generated {len(created_proposals)} proposals")
            return len(created_proposals)
            
        except Exception as e:
            logger.error(f"Autonomy loop failed: {e}")
            return 0
